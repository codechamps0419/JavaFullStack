Stream :
=========

Stream is a sequence of objects that supports various sequential and 
parallel aggregate operations. These operations can be performed on the objects in a stream
to produce results. It allows multiple intermediate operations chained together 
to aggregate the data, and the results are collected by applying a 
terminal operation on the data received.

Java stream is basically pipeline that consists of a stream source followed by zero or 
more intermediate operations and a terminal operation. 
Stream is not a collection or a data structure where we can store data.

A stream source is a Stream instance that contains the initial data.
Intermediate operations are used to perform actions on stream data and 
return another stream as output.
Terminal operations produce the result of the stream after all the intermediate operations
are applied.

Stream follows lazy evaluation, and all intermediate operations are performed on the stream only 
when a terminal operation is invoked.

~ Ways to create stream:
-------------------------

* Stream.empty() : This method creates an empty stream without any values. 
This avoids null pointer exceptions when calling methods with stream parameters.
  
* Stream.of(values/array/lists/..) : It creates a stream with the specified values. 
This method accepts both single and multiple values.

* Arrays.stream(arrName) : It creates a stream instance from an existing array. 
The resulting stream instance will have all the elements of the array.

* Stream.builder() : It returns a builder (a design pattern that allows us to construct an object 
 step-by-step) that can be used to add objects to the stream. The objects are added to the builder
 using the add() method. Calling build() method on the builder creates an instance of the Stream.
 
* Stream.concat(Stream s1, Stream s2) :  It combine two existing streams to produce a new stream.

* Stream.generate(Supplier<T> supplier) : It returns an infinite sequential unordered stream 
where the values are generated by the provided Supplier.

Infinite - The values in the stream are infinite (i.e.) unlimited.
Unordered - Repeated execution of the stream might produce different results.
Supplier - A functional interface in Java represents an operation that takes no argument and returns a result

Stream.generate() is useful to create infinite values like random integers, UUIDs (Universally Unique Identifiers), constants, etc. 
Since the resultant stream is infinite, it can be limited using the limit() method to 
make it run infinite time.

* Stream.iterate(T seed, UnaryOperator<T> unaryOperator) : It returns a infinite sequential ordered
 stream stream where the values are generated by the provided UnaryOperator.
 
 UnaryOperator - A functional interface in Java that takes one argument and returns a result 
 that is of the same type as its argument.
 
 ~ Different Operations on Streams :
 -----------------------------------
 
 1. Intermediate Operations : These operations return a stream as the output,and intermediate 
 operations are not executed until a terminal operation is invoked on the stream. 
 This is called lazy evaluation.
 
 * filter(): It returns a stream with the stream's elements that match the given predicate. 
 Predicate is a functional interface that accepts a single input and can return a boolean value.
 
 * map(): It returns a stream with the resultant elements after applying the given function 
 on the stream elements.
 
* sorted() : It returns a stream with the elements of the stream sorted according to 
natural order or the provided Comparator.

* distinct() : It returns a stream consisting of distinct elements of the stream (i.e.) 
it removes duplicate elements.

* peek() : It returns a stream consisting of the elements of the stream after performing 
the provided action on each element.

* limit() : It returns a stream with the stream elements limited to the provided size.

* skip() : It skips or discards specified stream elements and return remaining one.

2. Terminal Operations : These operations produce the results of the stream after all 
the intermediate operations are applied.

* forEach(), forEachOrdered(): These methods iterates and performs the specified action for 
each stream element. Difference between these methods is that forEachOrdered() maintains 
the order when the stream is parallel.

* collect() : It performs a mutable reduction operation on the elements of the stream
 using a Collector (class that implements various reduction operations such as accumulating 
 elements into collections, summarizing elements, etc.
 
 A mutable reduction is an operation in which the reduced value is a mutable result container, 
 like an ArrayList, Map, List, etc.
 
 * count() : It returns the total number of elements in the stream.
 
 * reduce() : It performs a reduction on the elements of the stream and returns the value.

 * toArray() : It returns an array of elements in the stream.
 
 * min() and max() : It return an Optional that contains the minimum and maximum
  elements of the stream.
  
 * findFirst() : It returns an Optional that contains the first element of the stream 
 or an empty Optional if the stream is empty. 
 
 * findAny() : It returns an Optional containing some element of the stream 
 or an empty Optional if the stream is empty.
 
 * noneMatch() : When no stream elements match the specified predicate, 
 the noneMatch() method returns true, otherwise false.
 
 * allMatch() : When all the stream elements meet the specified predicate, the allMatch() method
  returns true, otherwise false. If the stream is empty, it returns true.
  
 * anyMatch() : When any stream element matches the specified predicate, the anyMatch() method 
 returns true, otherwise false. If the stream is empty, it returns false.
 
 
~ Parallel Stream:
-----------------
All stream operations are sequential in Java unless explicitly specified as parallel. 
Parallel streams are created in Java in two ways.

1. Calling the parallel() method on a sequential stream :
		parallel() method is called on the existing sequential stream to make it parallel.
2. Calling parallelStream() method on a collection :
		It'ss called on Java collections like List, Set, etc to make it a parallel stream.

